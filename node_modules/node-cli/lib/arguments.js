"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Arguments = void 0;
const sortObjectByKeys = (obj) => {
    return Object.keys(obj)
        .sort()
        .reduce((result, key) => {
        result[key] = obj[key];
        return result;
    }, {});
};
class Arguments {
    constructor(...args) {
        this._parsedArgs = {};
        this._args = args.length > 0 ? args : process.argv.slice(2);
        this.parse();
    }
    get args() {
        return this._args;
    }
    get parsedArgs() {
        return this._parsedArgs;
    }
    parse() {
        const isOption = /^--\S+$/;
        const isShortOption = /^-[\w+]+$/;
        const hasEqualSign = /^(--[\w-]+)=([\S\s]+)$/;
        let options = false; // following args belong to an option
        const _tmp = [];
        let _args = {};
        // split merged short options (-ab => -a -b)
        this._args.forEach(a => {
            if (isShortOption.test(a)) {
                a.slice(1)
                    .split('')
                    .forEach(b => {
                    _tmp.push(`-${b}`);
                });
            }
            else
                _tmp.push(a);
        });
        let lastOpt = '';
        // add args => { _: ['arg']}
        const addArg = (a) => {
            if (!_args['_'])
                _args = { ..._args, _: [a] };
            else
                _args = { ..._args, _: [..._args['_'], a] };
        };
        // add options => { opt: []}
        const addOption = (a) => {
            lastOpt = a;
            if (typeof _args[a] === 'undefined')
                _args = { ..._args, [a]: [] };
        };
        // add args to options => { opt: ['arg1', 'arg2']}
        const addArgToOption = (a) => {
            const key = lastOpt;
            // @ts-ignore
            _args = { ..._args, [key]: [..._args[key], a] };
        };
        _tmp.forEach(a => {
            let isOpt = false;
            if (isOption.test(a) || isShortOption.test(a)) {
                isOpt = options = true;
            }
            if (hasEqualSign.test(a)) {
                const e = hasEqualSign.exec(a);
                if (e && e[1] && e[2]) {
                    addOption(e[1]);
                    addArgToOption(e[2]);
                    options = false;
                }
            }
            else if (!options) {
                addArg(a);
            }
            else if (isOpt) {
                addOption(a);
            }
            else if (lastOpt) {
                addArgToOption(a);
            }
        });
        this._parsedArgs = _args;
    }
    getArguments() {
        return this._parsedArgs['_'];
    }
    getOptions() {
        let _tmp = {};
        for (const [key, value] of Object.entries(this._parsedArgs)) {
            if (key !== '_') {
                _tmp = { ..._tmp, [key.replace(/-+/, '')]: value };
            }
        }
        return sortObjectByKeys(_tmp);
    }
    getOption(option, ...alias) {
        const opts = this.getOptions();
        if (!opts)
            return;
        if (opts[option])
            return opts[option];
        if (alias && Array.isArray(alias)) {
            for (const a of alias) {
                if (a && opts[a])
                    return opts[a];
            }
        }
        return;
    }
    hasOption(option, ...alias) {
        return this.getOption(option, ...alias) ? true : false;
    }
    getArgument(index) {
        const args = this.getArguments();
        if (!args)
            return;
        if (args[index])
            return args[index];
        else
            return;
    }
    hasArgument(arg) {
        const args = this.getArguments();
        if (!args)
            return false;
        return args.includes(arg);
    }
}
exports.Arguments = Arguments;
