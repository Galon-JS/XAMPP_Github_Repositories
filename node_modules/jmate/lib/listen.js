// Generated by CoffeeScript 1.12.7
(function() {
  var async, fs, path, settings;

  fs = require("fs");

  path = require("path");

  async = require("async");

  settings = require("./settings");

  module.exports = function(tcp, callback) {
    var chomp, cmdObj, fileIsWritable, firstLine, handleClose, handleCmd, handleFirstLine, handleSave, options, readLine, strBuffer;
    options = settings.options, fileIsWritable = settings.fileIsWritable;
    firstLine = true;
    strBuffer = "";
    cmdObj = {};
    chomp = function(line) {
      return line.replace(/(\n|\r)+$/, "");
    };
    handleSave = function(variables, data) {
      var backupFile, backupFileBase, bakCount, ex, file, writeStream;
      file = variables.token;
      if (fs.existsSync(file || fileIsWritable(file))) {
        try {
          if (options.verbose) {
            console.error("Saving file " + file);
          }
          if (fs.existsSync(file)) {
            backupFile = backupFileBase = file + ".bak";
            bakCount = 2;
            while (fs.existsSync(backupFile)) {
              backupFile = backupFileBase + ".bak" + bakCount;
              bakCount += 1;
            }
            if (options.verbose) {
              console.error("Backing up file to " + backupFile);
            }
            fs.linkSync(file, backupFile);
          }
          writeStream = fs.createWriteStream(file);
          return writeStream.end(data, "utf8", function() {
            if (fs.existsSync(backupFile)) {
              if (options.verbose) {
                console.error("Removing backup file " + backupFile);
              }
              return fs.unlinkSync(backupFile);
            }
          });
        } catch (error) {
          ex = error;
          if (options.verbose) {
            return console.error("Save failed: " + ex);
          }
        }
      } else {
        if (options.verbose) {
          return console.error("Skipping save, file is not writable");
        }
      }
    };
    handleClose = function(variables, data) {
      var file;
      file = variables.token;
      if (options.verbose) {
        return console.error("Closed file " + file);
      }
    };
    readLine = function(buff) {
      var idx, line;
      idx = buff.indexOf("\n");
      if (idx < 0) {
        return [null, buff];
      }
      if (idx === 0) {
        return ["", buff.slice(1)];
      }
      line = buff.slice(0, +(idx - 1) + 1 || 9e9);
      buff = buff.slice(idx + 1);
      return [line, buff];
    };
    handleCmd = function() {
      var assignData, cmd, line, name, ref, ref1, ref2, ref3, value;
      if (cmdObj.cmd == null) {
        ref = readLine(strBuffer), cmd = ref[0], strBuffer = ref[1];
        if (cmd == null) {
          return false;
        }
        cmdObj.cmd = cmd;
      }
      if (cmdObj.variables == null) {
        cmdObj.variables = {};
      }
      assignData = function() {
        var size;
        size = cmdObj.size;
        if (!(strBuffer.length >= size)) {
          return false;
        }
        cmdObj.data = strBuffer.slice(0, +(size - 1) + 1 || 9e9);
        strBuffer = strBuffer.slice(size);
        return true;
      };
      if ((cmdObj.size != null) && (cmdObj.data == null)) {
        if (!assignData()) {
          return false;
        }
      }
      ref1 = readLine(strBuffer), line = ref1[0], strBuffer = ref1[1];
      if (line == null) {
        return false;
      }
      while (line !== "") {
        ref2 = line.split(": ", 2), name = ref2[0], value = ref2[1];
        if (name === "data") {
          cmdObj.size = parseInt(value);
          if (!assignData()) {
            return false;
          }
        } else {
          cmdObj.variables[name] = value;
        }
        ref3 = readLine(strBuffer), line = ref3[0], strBuffer = ref3[1];
        if (line == null) {
          return false;
        }
      }
      switch (cmdObj.cmd) {
        case "save":
          handleSave(cmdObj.variables, cmdObj.data);
          break;
        case "close":
          handleClose(cmdObj.variables, cmdObj.data);
          break;
        default:
          console.error("Received unknown command " + cmd + ", exiting...");
          process.exit(1);
      }
      cmdObj = {};
      return true;
    };
    handleFirstLine = function() {
      var idx, line;
      idx = strBuffer.indexOf("\n");
      if (idx < 0) {
        return false;
      }
      line = strBuffer.slice(0, +idx + 1 || 9e9);
      if (options.verbose) {
        console.error("Editor: " + (chomp(line)));
      }
      strBuffer = strBuffer.slice(idx + 1);
      firstLine = false;
      return true;
    };
    tcp.on('data', function(data) {
      var handleData;
      handleData = function() {
        if (!(strBuffer.length > 0)) {
          return;
        }
        if (firstLine) {
          if (handleFirstLine()) {
            return handleData();
          }
        } else {
          if (handleCmd()) {
            return handleData();
          }
        }
      };
      strBuffer += data.toString("utf8");
      return handleData();
    });
    tcp.on('end', function() {
      tcp.end();
      return callback();
    });
    return tcp.on('error', function(err) {
      return callback(err);
    });
  };

}).call(this);
